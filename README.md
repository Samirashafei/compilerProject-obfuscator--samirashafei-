# compilerProject-obfuscator--samirashafei-

اعضای گروه 
پرنیان بهرامی 
سمیرا شفیعی 

```markdown
# MiniC Obfuscator

ساختار پروژه :
MiniC-Obfuscator/
├── MiniCLexer.py
├── MiniCParser.py
├── ObfuscatorVisitor.py
├── obfuscator.py
├── test.c
└── README.md
# ابزار پروژه
- antlr 
- python
- graphiz
- argparse
- random

# 🛠️ روند اجرای پروژه MiniC Obfuscator

## مراحل پیش‌پردازش قبل از اعمال تکنیک‌های مبهم‌سازی

قبل از شروع فرآیند Obfuscation، لازم است یک سری مراحل اولیه روی کد منبع انجام شوند. این مراحل در فایل `test.py` پیاده‌سازی شده‌اند و شامل موارد زیر هستند:

### 🔹 مرحله ۱: خواندن فایل منبع
ابتدا فایل کد منبع با پسوند `.mc` (مثلاً `input.mc`) خوانده می‌شود.

### 🔹 مرحله ۲: تحلیل واژگانی (Lexer)
با استفاده از فایل گرامر `MiniC.g4` که توسط ANTLR تعریف شده، فایل‌های پایتونی مانند `MiniCLexer.py` تولید می‌شوند.

در این مرحله، کلمات کلیدی مانند `return`، شناسه‌ها، عملگرها و ... توسط Lexer به **توکن**‌های قابل فهم برای مرحله بعدی تبدیل می‌شوند.

### 🔹 مرحله ۳: تحلیل نحوی (Parser)
توکن‌های تولیدشده توسط Lexer به Parser داده می‌شوند تا **درخت نحو (Parse Tree)** بر اساس ساختار گرامری زبان MiniC ساخته شود.

### 🔹 مرحله ۴: نمایش درخت نحو
درخت نحو تولیدشده در ترمینال به‌صورت متنی نمایش داده می‌شود.

### 🔹 مرحله ۵: تولید نمایش گرافیکی درخت
برای نمایش بصری درخت نحو:
- از نرم‌افزار **Graphviz** استفاده می‌کنیم.
- ابتدا نمایش متنی درخت را در قالب فایل `.dot` ذخیره می‌کنیم.
- سپس با استفاده از Graphviz، فایل `.dot` را به فرمت تصویری مانند `.png` یا `.pdf` تبدیل می‌کنیم.
- کدی برای تبدیل نمایش متنی به `.dot` در فایل `test.py` نوشته شده است.

---
## 🎯 شروع فرآیند مبهم‌سازی (Obfuscation)

در بخش دوم پروژه، با استفاده از سه تکنیک رایج، کد منبع را مبهم می‌کنیم:

### ✅ تکنیک اول: تغییر نام شناسه‌ها (Identifiers)
- در فایل `ObfuscatorVisitor.py`، کلاسی به نام `ObfuscatorVisitor` تعریف شده که از کلاس پایه `MiniCVisitor` ارث‌بری می‌کند.
- در این کلاس، مکان‌هایی از کد که شناسه‌ها (نام توابع، متغیرها و ...) استفاده شده‌اند شناسایی می‌شوند.
- برای هر شناسه، یک نام تصادفی یا مشخص جایگزین می‌شود و این تغییر در سراسر کد اعمال می‌گردد.
-  نگاشتی به‌صورت دیکشنری از نام‌های اصلی به نام‌های جدید نگه‌داری می‌شود تا انسجام حفظ شود.و
- از ان در مراحل دیگر مثل تابع جایگزینی عبارات استفاده لازم را بکنیم 
##  تکنیک بازنویسی عبارات (Expression Replacement)
این تغییرات باعث سخت‌ فهم شدن منطق کد برای افراد غیرمجاز می‌شوند.

برای این کار، در فایل `obfuscate_to_file.py` تابعی به نام `replace_expression_pattern` پیاده‌سازی کردیم.

### ⚙️ ورودی‌های تابع:

- `tokens`: لیستی از توکن‌ها
- `i`: اندیس شروع بررسی
- `name_map`: نگاشت برای جایگزینی نام‌های متغیرها

### 🧪 مراحل اجرا:

1. ابتدا بررسی می‌شود که آیا حداقل ۳ توکن بعد از اندیس فعلی وجود دارد یا نه.
   - اگر کمتر باشد، تابع با خروجی `None` و پیشروی یک‌ گام (`1`) پایان می‌یابد.

2. اگر الگوی سه‌تایی زیر وجود داشته باشد:
- `Operand1` و `Operand2` باید از نوع `Identifier` یا `IntegerConstant` باشند.
- `Operator` می‌تواند یکی از عملگرهای `+`, `-`, `*`, `/`, `==`, `&&`, `||` باشد.

3. اگر شناسه‌ای در `name_map` باشد، با نام جدیدش جایگزین می‌شود.

4. سپس عملگر بررسی شده و بسته به نوع آن، عبارت بازنویسی می‌شود:
- `a + b` → `a - (-b)`
- `a - b` → `a + (-b)`
- `a * 2` → `a << 1`
- `a / 2` → `a >> 1`
- `a == b` → `! (a != b)`
- `a && b` → `!(!a || !b)`
- `a || b` → `!(!a && !b)`

در این روش، در حالی که نتیجه‌ی منطقی تغییر نمی‌کند، کد پیچیده‌تر شده و فهم آن برای افراد غیرمجاز سخت‌تر می‌شود.
---
### ✅ تکنیک سوم: درج کد مرده (Dead Code Insertion)

- کدهایی که هیچ‌گاه اجرا نمی‌شوند به‌صورت تصادفی در بلاک‌ها اضافه می‌شوند.

- مثال‌ها:
  - `if (0) { printf("This won't run"); }`
  - تعریف متغیرهای بدون استفاده مانند `int dead = 1234;`

- این تکنیک خوانایی کد را کاهش می‌دهد ولی عملکرد آن را تغییر نمی‌دهد.

- اول یک سری کد که رو خروجی برنامه اصلی تاثیری ندارند در یک تابع `get_random_dead_code()` تعریف میکنیم.

- کد مرده را در نقاطی از کد اصلی لحاظ میکنیم:
  - در شروع یک بلاک کد یعنی بعد از `{`
  - بعد از پایان دستور با احتمال 30 درصد یک کد مرده اضافه میکنیم

### 🛠️ بخش امتیازی: استفاده از CLI برای اجرای پروژه

برای اینکه بتوانیم با زدن دستور در خط فرمان، پروژه را اجرا کنیم:

- ابتدا باید با استفاده از `import argparse` در فایل اصلی (main) تعریف‌های لازم را انجام دهیم تا خط فرمان را پردازش کند.

- آرگومان‌های ورودی در خط فرمان به شکل زیر تعریف می‌شوند:

  - `--input` : بعد از این گزینه، نام فایل ورودی قرار می‌گیرد.
  - `--output` : بعد از این گزینه، نام فایل خروجی مشخص می‌شود.
  - `--techniques` : لیست تکنیک‌های مبهم‌سازی که می‌خواهیم اعمال شوند.

- تکنیک‌ها که به‌صورت رشته هستند، باید به لیست تبدیل شوند تا بتوان روی آن‌ها پردازش انجام داد.

- در نهایت تابع `obfuscate_and_save` را بازنویسی می‌کنیم تا:
  - پارامترهای ورودی و خروجی را به صورت آرگومان دریافت کند.
  - تکنیک‌های انتخاب‌شده را بررسی کرده و منطق اجرا را بر اساس آن‌ها کنترل کند.
  
# struct و pointer پشتیبانی
گرامر زبان تعریف‌ شده در فایل MiniC.g4 به‌گونه‌ای طراحی شده است که از ساختارهای struct و اشاره‌گرها (pointer) پشتیبانی کامل دارد.

# ✅ تست عملی
برای بررسی عملکرد این ویژگی‌ها، فایلی با نام testsp.mc ایجاد شد که در آن از struct و pointer استفاده شده است. پس از اجرای برنامه و مشاهده خروجی بدون بروز خطا، صحت عملکرد گرامر در این موارد تأیید شد.
# تعریف  struct 
در گرامر، نوع struct در قاعده‌ی typeSpecifier مشخص شده و همچنین قاعده‌ای مجزا برای تعریف ساختار با عنوان structDefinition در نظر گرفته شده است
# تعریف pointer
پشتیبانی از اشاره‌گرها از طریق قاعده‌ی pointerSpecifier انجام شده و در مکان‌هایی مانند declaration و parameter به‌کار رفته است
# دسترسی به اعضای struct و pointer
دسترسی به اعضای یک struct یا اشاره‌گر به struct از طریق قاعده‌ی postfixExpression در گرامر پشتیبانی می‌شود
بنابراین، دو حالت زیر در زبان قابل استفاده هستند
p.name برای دسترسی به اعضای یک struct معمولی
p->name برای دسترسی به اعضای ساختار از طریق اشاره‌گر به struct



## 💾 نتیجه نهایی
در پایان اجرای ابزار:
- کدی تولید می‌شود که عملکردش حفظ شده اما ساختارش تغییر یافته است.
- خروجی نهایی در فایل مشخص‌شده (مثلاً `output.c`) ذخیره می‌شود.
- پیام موفقیت در ترمینال چاپ می‌شود.

## نحوه اجرا

```bash
python obfuscator.py --input test.c --output out.c --techniques rename,deadcode,expr
